<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DjCap - Visual Viewer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #0f172a;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
        }
        .player-shell {
            width: min(100vw, calc(100vh * 16 / 9));
            height: min(100vh, calc(100vw * 9 / 16));
            max-width: 1000px;
            max-height: 1000px;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            position: relative;
        }
        .player-shell video, .player-shell img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }
        .badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.6);
            padding: 6px 10px;
            border-radius: 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .gif-index-bar {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 10px;
            display: flex;
            justify-content: center;
            gap: 8px;
            pointer-events: none; /* allow video interactions except buttons */
        }
        .gif-index-btn {
            pointer-events: auto;
            background: rgba(255,255,255,0.85);
            color: #111;
            border: 0;
            border-radius: 999px;
            padding: 4px 9px;
            font-size: 12px;
            font-weight: 800;
            cursor: pointer;
        }
        .gif-index-btn.active {
            background: rgba(99, 102, 241, 0.95);
            color: #fff;
        }
        .lyrics-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 12px 16px 14px;
            background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 30%, rgba(0,0,0,0.8) 100%);
        }
        .lyrics-title {
            font-size: 12px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #cbd5e1;
            margin-bottom: 6px;
        }
        .lyrics-lines {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .lyric-line {
            font-size: 15px;
            line-height: 1.4;
            color: #e2e8f0;
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body>
<div id="app">
    <div class="player-shell">
        <div class="badge" v-if="activeDeckName">
            <span>{{ activeDeckName.toUpperCase() }} â€¢ {{ activeDeckData?.title || 'Loading...' }}</span>
        </div>
        <video v-if="currentGifVideoUrl"
               :src="currentGifVideoUrl"
               :poster="currentGifUrl"
               playsinline
               muted
               preload="auto"
               @loadedmetadata="onVideoLoaded"
               @ended="onVideoEnded"
               autoplay></video>
        <img v-else
             :src="currentGifUrl"
             :alt="currentGifTitle"
             @error="handleImageError"
             @load="onGifLoad">

        <div class="gif-index-bar" v-if="gifCount > 0" aria-label="GIF slots">
            <button
                v-for="n in gifCount"
                :key="n"
                class="gif-index-btn"
                :class="{ active: (n - 1) === currentGifIndex }"
                @click="removeGifAt(n - 1)"
                :title="`Remove GIF #${n} from rotation`"
            >{{ n }}</button>
        </div>

        <div class="lyrics-panel" v-if="lyricsPreview && lyricsPreview.length">
            <div class="lyrics-title">Lyrics</div>
            <div class="lyrics-lines">
                <div v-for="(line, idx) in lyricsPreview" :key="idx" class="lyric-line">
                    {{ line }}
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const { createApp } = Vue;

createApp({
    data() {
        return {
            enrichedData: null,
            gifs: [],
            gifPool: [],
            bannedGifIds: [],
            gifKeywords: [],
            currentGifIndex: 0,
            lastGifTrackId: null,
            lastGifFetchAt: 0,
            lastGifKeywordsSig: '',
            recentGifIds: [],
            maxRecentGifHistory: 100,
            gifFetchLimit: 20,
            gifRefreshMs: 10000,
            gifTimeoutId: null,
            activeVideoRef: null,
            gifPlaybackRateBase: 120,
            gifFallbackDurationMs: 2000,
            pollInterval: null
        };
    },
    computed: {
        activeDeckName() {
            if (!this.enrichedData) return null;
            const fromActive = this.enrichedData.active_deck;
            if (fromActive && this.enrichedData[fromActive]) return fromActive;
            if (this.getDeckActive('deck1') && this.enrichedData.deck1) return 'deck1';
            if (this.getDeckActive('deck2') && this.enrichedData.deck2) return 'deck2';
            if (this.enrichedData.deck1) return 'deck1';
            if (this.enrichedData.deck2) return 'deck2';
            return null;
        },
        activeDeckData() {
            if (!this.enrichedData || !this.activeDeckName) return null;
            return this.enrichedData[this.activeDeckName] || null;
        },
        gifCount() {
            return this.gifs ? this.gifs.length : 0;
        },
        currentGif() {
            if (!this.gifs || this.gifs.length === 0) return null;
            return this.gifs[this.currentGifIndex % this.gifs.length];
        },
        currentGifUrl() {
            if (!this.currentGif) return '';
            return this.currentGif.url || '';
        },
        currentGifVideoUrl() {
            if (!this.currentGif) return '';
            const url = (this.currentGif.url || '').toLowerCase();
            const mime = (this.currentGif.mime || '').toLowerCase();
            if (mime.startsWith('video/') || url.endsWith('.mp4')) return this.currentGif.url;
            return '';
        },
        currentGifTitle() {
            return this.currentGif?.title || 'GIF';
        },
        lyricsPreview() {
            const deck = this.activeDeckData;
            if (!deck) return [];

            // Prefer synced lines if present
            if (deck.lyrics_synced && Array.isArray(deck.lyrics_synced) && deck.lyrics_synced.length > 0) {
                return deck.lyrics_synced.slice(0, 4).map(entry => entry.line).filter(Boolean);
            }

            // Fallback to raw lyrics, first few lines
            if (deck.lyrics_raw) {
                return String(deck.lyrics_raw).split(/\r?\n/).map(l => l.trim()).filter(Boolean).slice(0, 4);
            }

            return [];
        }
    },
    mounted() {
        this.fetchData();
        this.pollInterval = setInterval(() => this.fetchData(), 2000);
    },
    beforeUnmount() {
        if (this.pollInterval) clearInterval(this.pollInterval);
        if (this.gifTimeoutId) clearTimeout(this.gifTimeoutId);
    },
    methods: {
        async fetchData() {
            try {
                const response = await fetch('/api/enriched', { headers: { 'Accept': 'application/json' }, cache: 'no-cache' });
                if (response.ok) {
                    this.enrichedData = await response.json();
                    await this.fetchGifsForActiveDeck();
                }
            } catch (_) {}
        },
        async fetchGifsForActiveDeck() {
            const deck = this.activeDeckData;
            if (!deck || !deck.title || !deck.artist) {
                this.gifs = [];
                this.gifPool = [];
                this.bannedGifIds = [];
                this.gifKeywords = [];
                this.lastGifTrackId = null;
                this.lastGifKeywordsSig = '';
                this.resetGifTimers();
                return;
            }
            const trackId = `${this.activeDeckName || 'deck'}|${deck.title}|${deck.artist}|${deck.key || ''}`;
            const trackChanged = this.lastGifTrackId !== trackId;
            if (!trackChanged && this.gifs && this.gifs.length > 0) return;

            // Use GIFs embedded in /api/enriched (no extra API calls / loops).
            const allGifs = Array.isArray(deck.gifs) ? deck.gifs : [];
            this.gifPool = Array.isArray(deck.gif_pool) && deck.gif_pool.length > 0 ? deck.gif_pool : allGifs;
            this.bannedGifIds = [];
            const filtered = allGifs.filter(g => g?.id && !this.recentGifIds.includes(g.id));
            const selected = filtered.length > 0 ? filtered : allGifs;
            const shuffled = this.shuffleArray(selected.slice());
            this.gifs = shuffled;

            // Show EXACTLY what we feed into the GIF search (artist-only policy)
            if (Array.isArray(deck.giphy_query_parts) && deck.giphy_query_parts.length >= 1) {
                this.gifKeywords = deck.giphy_query_parts.slice(0, 1).map(String);
            } else {
                const a = deck.artist ? String(deck.artist) : 'Unknown Artist';
                this.gifKeywords = [a];
            }
            this.lastGifTrackId = trackId;
            this.lastGifFetchAt = Date.now();
            this.lastGifKeywordsSig = `${deck.giphy_query || ''}`;
            this.currentGifIndex = 0;
            this.resetGifTimers();
        },

        getGifId(gif) {
            if (!gif) return '';
            return String(gif.id || gif.url || '');
        },

        removeGifAt(index) {
            if (!this.gifs || this.gifs.length === 0) return;
            if (index < 0 || index >= this.gifs.length) return;

            const removed = this.gifs[index];
            const removedId = this.getGifId(removed);
            if (removedId && !this.bannedGifIds.includes(removedId)) this.bannedGifIds.push(removedId);

            const next = this.gifs.slice();
            next.splice(index, 1);
            this.gifs = next;

            if (this.currentGifIndex > index) this.currentGifIndex -= 1;
            if (this.currentGifIndex >= this.gifs.length) this.currentGifIndex = 0;

            const currentIds = new Set(this.gifs.map(g => this.getGifId(g)));
            const replacement = (this.gifPool || []).find(g => {
                const id = this.getGifId(g);
                if (!id) return false;
                if (this.bannedGifIds.includes(id)) return false;
                if (currentIds.has(id)) return false;
                return true;
            });
            if (replacement) this.gifs.push(replacement);

            this.resetGifTimers();
        },
        getDeckActive(deckName) {
            if (this.enrichedData && this.enrichedData[deckName]) {
                const deck = this.enrichedData[deckName];
                if (deck && typeof deck.active === 'boolean') return deck.active;
            }
            return this.enrichedData && this.enrichedData.active_deck === deckName;
        },
        handleImageError(event) { event.target.style.display = 'none'; },
        resetGifTimers() {
            if (this.gifTimeoutId) clearTimeout(this.gifTimeoutId);
            this.gifTimeoutId = null;
            this.activeVideoRef = null;
        },
        advanceGif() {
            if (!this.activeDeckData || this.gifCount === 0) return;
            const current = this.currentGif;
            if (current && current.id) {
                this.recentGifIds.push(current.id);
                if (this.recentGifIds.length > this.maxRecentGifHistory) {
                    this.recentGifIds.splice(0, this.recentGifIds.length - this.maxRecentGifHistory);
                }
            }
            this.resetGifTimers();
            this.currentGifIndex = (this.currentGifIndex + 1) % this.gifCount;
        },
        shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        },
        onGifLoad() {
            const bpm = this.activeDeckData?.bpm || this.gifPlaybackRateBase;
            const bpmFactor = bpm / this.gifPlaybackRateBase;
            const duration = Math.max(500, this.gifFallbackDurationMs / bpmFactor);
            this.resetGifTimers();
            this.gifTimeoutId = setTimeout(() => this.advanceGif(), duration);
        },
        onVideoLoaded(event) {
            const video = event.target;
            this.activeVideoRef = video;
            const bpm = this.activeDeckData?.bpm || this.gifPlaybackRateBase;
            const rate = bpm / this.gifPlaybackRateBase;
            video.playbackRate = rate;
            video.currentTime = 0;
            video.loop = false;
            video.muted = true;
            this.resetGifTimers();
            video.play().catch(() => {});
        },
        onVideoEnded() { this.advanceGif(); }
    }
}).mount('#app');
</script>
</body>
</html>



